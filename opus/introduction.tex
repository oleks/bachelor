\chapter{Introduction}\label{section:introduction}

\section{Motivation}

The generic halting problem, or the \emph{Entscheidungsproblem}, was formulated
well before the invention of the modern computer. It was formulated at a time
when many mathematicians believed that they could formalize all of mathematics
and use algorithmic means to formally prove all statements within that formal
system. The problem can be stated as follows:

\begin{definition} Given the set of all possible programs $P$, find a program
$p\in P$, that can for any $p'\in P$,  within a finite amount of time return
\mono{halts}\ or $\text{\mono{doesn't halt}}$, depending on whether $p'$
eventually stops or runs indefinitely, respectively.\end{definition}
 
While the concept of a program remains to be formally defined, an important
part of that definition is that it is a finite sequence of discrete,
terminating steps. Hence, the problem can be restated as determining whether
the given program contains program flow cycles that loop indefinitely.

Alan A. Turing and Alonzo D. Church developed separate proofs for the
infeasibility of such a program almost simultaneously in 1937. Turing's proof
however, would become the one more widely recognised, although they are
mutually reducible to one another.

However, the fact that termination checking is infeasible \emph{in general},
has unfortunately become an easy excuse for many to claim that the property is
\emph{always} undecidable. 

The motivation behind this project is to examine some of the contexts in which
the halting property \emph{is} decidable in a matter that is both sound and
complete. To those unfamiliar with logic, a \emph{sound} proof is a proof that
produces the correct result for any query, and a \emph{complete} proof is a
proof that always terminates.

To do this for a generic program\footnote{A term that also remains to be
formally defined.} we need to slightly relax the definition of the halting
problem allowing for the answer \mono{unknown} to be returned. The goal is then
to reduce the number of programs in $P$ for which the termination checking
program returns the result \mono{unknown}.

\begin{definition} Given the set of all possible programs $P$, find a program
$p\in P$, that can for any $p'\in P$, within a finite amount of time, either
give up and return \mono{unknown}, or return \mono{halts}\ or
$\text{\mono{doesn't halt}}$, depending on whether $p'$ eventually stops or
runs indefinitely, respectively. Find a $p$ such that the number of $p'\in P$
for which $p$ returns \mono{unknown} is minimized.\end{definition}

\section{Expectations of the reader}

The reader is expected to have a background in computer science on a graduate
level or higher. In particular, it is expected that the reader is familiar with
basic concepts of compilers, computability and complexity, discrete
mathematics, and basic concepts of functional programming languages (Monads
excluded). All of these topics, at the present state of writing, are subject to
basic undergraduate courses in computer science. Ideally, the reader should be
well familiar with at least one purely functional programming language such as
ML or Haskell.

More exemplary, the following concepts shouldn't frighten you:

\begin{itemize}

\item Algorithm, Big-O notation.

\item Function, expression, pattern, pattern matching, loop, recursion.

\item Induction, variant, invariant.

\item Regular expressions.

\item Backus-Naur Form, structured operational semantics.

\item Turing machine, the halting problem.

\item Set, list, tuple, head, tail.

\item Graph, node, edge, path, cycle.

\end{itemize}

\section{Preliminaries}

To avoid ambiguity and to aid some of the discussions below, we provide the
following definitions.

\begin{definition} Let $\mathbb{N}^0$ denote the set of nonnegative integers
and let $\mathbb{N}$ denote the set of positive integers.\end{definition}

\begin{definition} When dealing with variables that are insignificant to some
definition, lemma, theorem, etc. we might simply denote them as $\_$, which
carries over the conventional ``wildcard'' meaning from functional
languages.\end{definition}

\begin{definition} When dealing with lists, aka. finite ordered sequences,
we'll adopt the following notational constructs:

\begin{enumerate}

\item Given a list $L$ and a possibly infinite set $S$, we say that $L\subset
S$, if $L$ consists solely of elements also contained in $S$.

\item Given a list $L$, $|L|\in\mathbb{N}^0$ and denotes the length of $L$.

\item Any given list $L$ is the ordered sequence $l_1,l_2,\cdots,l_{|L|}$.

\item Given a list $L$ and an element $l$, we say that $l\in L$ if $l$ is one
of $l_1,l_2,\cdots,l_{|L|}$.

\item Lists may be nested, hence, given an element $e$ and a list $l$, we say
that $e\Subset l$ if $e$ is contained in either $l$ or one of its nested lists.

\item Given the lists $L$ and $L'$ we say that $L=L'$ iff $|L|=|L'|$ and
$\forall\ i\in \{i\mid i\in\mathbb{N} \wedge i \leq |L|\}\ l_i=l'_i$.

\item Given a list $L=l_1,l_2,\cdots,l_{|L|}$, $L_{head}$ refers to $l_1$, and
$L_{tail}$ refers to the sequence $l_2,l_3,\cdots,l_{|L|}$.

\item $\emptyset$ denotes the empty list.

\item $\left[ term \mid variables \in spaces, precondition \right]$ denotes a
finite sequence where each element is constructed from evaluating the ``term'',
containing the given ``variables'' are in the given ``spaces'', and fulfilling
the ``precondition''. This is reminiscent of conventional list comprehension.

\end{enumerate}

\end{definition}

For lists, we need not necessarily know the size, hence we often refer to lists
of some particular known size as tuples.

\begin{definition} A tuple is a sequence of a known size, represented as a
comma-separated list enclosed in $\left\langle \right\rangle$. A tuple
definition has the form $\left\langle x_1,x_2,\ldots,x_n \right\rangle : S_1,
S_2, \ldots, S_n$, meaning $x_1\in S_1, x_2\in S_2, \ldots, x_n\in S_n$, where
$n\in\mathbb{N}^0$.\end{definition}

\section{Chapter overview}

\begin{description}[\setleftmargin{70pt}\setlabelstyle{\bf}]

\item [Chapter 2]

\item [Chapter 3] This chapter formally introduces a Turing-complete language
called \D{}, that will be used to aid the discussions in latter chapters. We
discuss data representation in \D{}, define the syntax and semantics for the
language, provide some sample programs and show that \D{} is Turing-complete.

\item [Chapter 4] This chapter describes the size change termination principle
and describes how the technique can be applied to \D{} programs. While the
chapter seeks to describe the concepts known from \cite{size-change} it does so
with a heavy reliance on \D{}, so it is recommended to be familiar with Chapter
3.

\item [Chapter 5] This chapter proposes a small extension to size-change
termination, dubbed shape-change termination, that allows to determine the
halting property for a slightly wider class of programs. This chapter exploits
many of the definitions in both Chapters 3 \& 4, so it is recommended to have
read those beforehand.

\end{description}
