\chapter{On the general uncomputability of the halting problem}

A computable problem is a problem that can be solved by an effective procedure.

A problem can be solved by an effective procedure iff the effective procedure
is well-defined for the entire problem domain\footnote{Invalid inputs are, in
this instance, irrelevant.}, and iff passing a value from the domain as input
to the procedure \emph{eventually} yields a correct result (to the problem) as
output of the procedure. That is, an effective procedure can solve a problem if
it computes an injective partial function that associates the problem domain
with the range of solutions to the problem.

An effective procedure is discrete, in the sense that computing the said
function cannot take an infinite amount of time. To do this, an effective
procedure makes use of a finite sequence of steps that themselves are discrete.
This has a few inevitable consequences for the input and output values, namely
that they themselves must be discrete that there must be a discrete number of
them.

\begin{proof} An infinite value cannot be processed nor produced by a finite
sequence of discrete steps.\end{proof}

An effective procedure is also deterministic, in the sense that passing the
same input value always yields the same output value. This means that all of
the steps of the procedure that are relevant to it's output are themselves
deterministic\footnote{All other steps can be omitted without loss of
generality.}. Together with the discreteness property, this property has the
ironic consequence that a computable function cannot produce a random value,
but only pass one on\cite{knuth-random}.

In effect, a procedure can be said to comprise of a finite sequence of other
procedures, some basic, others composite, which it executes in order to produce
an output value.

Bah this is not enough.. write about scope


\section{Blaaaaah}

An effective procedure itself, is a finite sequence of discrete and
deterministic instructions, that is, without any continuous or stochastic
processes. Each instruction 

As indicated, it takes an input value and produces an output
value. If no values serve as input or no values serve as output, the

The procedure input is a continuous machine state, the output is a discrete
change of the continuous state. And yet, the values that a procedure may use to
produce it's result are all discrete.

Instructions that the computer can execute may have no effect, but such
instructions are seldom of any particular interest. More amusing instructions
alter some sort of state that the computer withkeeps across instructions.

Such changes should be discrete and deterministic, that is, such that continous
and stochastic processes are not involved.

An instruction
commands a machine to perform a discrete and deterministic alternation of the
it's own state. For the simplest of purposes, the machine state can comprise of
the index of the currently executing instruction, known as the program counter,
the current state of the machine memory (tape), and the finite sequence of
instructions that the machine is using as it's program.

The machine state comprises of the state of the tape, the current position on
tape and the program.

Procedures themselves are algorithms, comprised of text, or more specifically,
a finite sequence of instructions. Each instruction is a finite, discrete and
deterministic operation, theoretically equivalent to a procedure.. so
procedures consist of procedures, but some procedures must be implemented in
underlying hardware.. meh Turing machines.

finite, discrete and deterministic instructions, that is,
without infinite, continous or stochastic processes. Procedures hence consume a
value as \emph{input} and produce a value as \emph{output}. These values are
finite in the sense that they can be represented as a finite sequence of bits.
No input or output values can in this sense be represented by empty sequences.
If conversely, multiple values are to serve as either input or output, a simple
value composition scheme can be devised:

Instructions themselves are procedures...

Suppose a binary digit representation of all values. Then the longest possible
value in the value composition will be of some finite length. All other values
can be padded from the left with $0$'s to fit that length, and the sequence can
begin with an additional number (of same width) indicating the number of
elements in the composite.

How do we know how wide the first number is?

They operate on finite
values, and the finiteness of values, individual instructions and the
instruction sequence means that the effective procedure eventually halts or
goes into an infinite loop for any given input. 

The instruction sequence, is by it's sequential nature enumerable. Initial
program execution would be to iterate through the sequence in a particular
direction, e.g. top-down. In this process we implicitly make use of a ``program
counter'', which is a value that points to the index of the next instruction to
execute. When the program counter moves past the end of the instruction
sequence, the procedure halts.

In this model, a ``loop'' is constructable by having a special \emph{jump}
instruction that changes the program counter to some value less than the
current program counter.

A ``loop'' can be constructed by a sequence of such instructions, due it's
sequential nature being enumerable, and with the existance of a special
\emph{jump} instruction, that changes the 

Clearly, a procedure that eventually halts and returns the correct output for
every input in the problem domain, solves the problem.


Procedures take in an input value and produce an output value. Multiple values
can be represented as a single value via. a pairing function.



\section{Computation environment}

Finitely many different instructions

A procedure is a finite length sequence of instructions, i.e. a countable set
that can be enumerated.

Every instruction is discrete, as in there are no continuous processes.

Every instruction is deterministic, as in there are no stochastic processes.

\section{Effectiveness}

Effective procedure

Effectively enumerable

Effectively decidable

Recursively enumerable -- countable sets

Co-recursively enumerable


% 155
% 22
% 23
% 170
% 98
% 141
% 54
% 163
% 115

\section{The halting problem}

\section{Rice's statement}
