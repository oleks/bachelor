\chapter{On the general uncomputability of the halting problem}

\section{Computable problems and effective procedures}

A computable problem is a problem that can be solved by an effective procedure.

A problem can be solved by an effective procedure iff the effective procedure
is well-defined for the entire problem domain\footnote{Invalid inputs are, in
this instance, irrelevant.}, and iff passing a value from the domain as input
to the procedure \emph{eventually} yields a correct result (to the problem) as
output of the procedure. That is, an effective procedure can solve a problem if
it computes an injective partial function that associates the problem domain
with the range of solutions to the problem.

An effective procedure is discrete, in the sense that computing the said
function cannot take an infinite amount of time. To do this, an effective
procedure makes use of a finite sequence of steps that themselves are discrete.
This has a few inevitable consequences for the input and output values, namely
that they themselves must be discrete and that there must be a discrete number
of them\footnote{A finite sequence of discrete values can be trivially encoded
as a single discrete value.}.

\begin{proof} An infinite value cannot be processed nor produced by a finite
sequence of discrete steps.\end{proof}

An effective procedure is also deterministic, in the sense that passing the
same input value always yields the same output value. This means that all of
the steps of the procedure that are relevant to it's output\footnote{All other
steps can be omitted without loss of generality.} are themselves deterministic.

\begin{proof} If a procedure made use of a stochastic process to yield a
result, that stochastic process would have to yield the output for the same
input if the global deterministic property of the procedure is to be withheld.
This is clearly absurd.\end{proof}

In effect, a procedure can be said to comprise of a finite sequence of other
procedures, which themselves may comprise of other procedures, however, all
procedures eventually bottom out, in that a finite sequence of composite
procedures can always be replaced by a finite sequence of basic procedures that
are implemented in underlying hardware.

%The procedure input is a continuous machine state, the output is a discrete
%change of the continuous state. And yet, the values that a procedure may use to
%produce it's result are all discrete.

%Instructions that the computer can execute may have no effect, but such
%instructions are seldom of any particular interest. More amusing instructions
%alter some sort of state that the computer withkeeps across instructions.

%An instruction
%commands a machine to perform a discrete and deterministic alternation of the
%it's own state. For the simplest of purposes, the machine state can comprise of
%the index of the currently executing instruction, known as the program counter,
%the current state of the machine memory (tape), and the finite sequence of
%instructions that the machine is using as it's program.

%The machine state comprises of the state of the tape, the current position on
%tape and the program.

%The instruction sequence, is by it's sequential nature enumerable. Initial
%program execution would be to iterate through the sequence in a particular
%direction, e.g. top-down. In this process we implicitly make use of a ``program
%counter'', which is a value that points to the index of the next instruction to
%execute. When the program counter moves past the end of the instruction
%sequence, the procedure halts.

%In this model, a ``loop'' is constructable by having a special \emph{jump}
%instruction that changes the program counter to some value less than the
%current program counter.

%A ``loop'' can be constructed by a sequence of such instructions, due it's
%sequential nature being enumerable, and with the existance of a special
%\emph{jump} instruction, that changes the 

%Clearly, a procedure that eventually halts and returns the correct output for
%every input in the problem domain, solves the problem.


%Procedures take in an input value and produce an output value. Multiple values
%can be represented as a single value via. a pairing function.

\begin{itemize}

\item effective procedure

\item effectively decidable

\item effectively enumerable

\end{itemize}


\section{Enumerability}

\subsection{Enumerable sets}

Enumerable sets, or equivalently countable or recursively enumerable sets, are
sets that can be put into a one-to-one correspondence to the set of natural
numbers $\mathbb{N}$, more specifically:

\begin{definition} An enumerable set is either the empty set or a set who's
elements can placed in a sequence s.t. each element gets a consecutive number
from the set of natural numbers $\mathbb{N}$.\end{definition}

\subsection{Decidability}

\begin{definition} A problems is decidable if there exists an algorithm that for any input event
\end{definition}

\begin{itemize}

\item Recursively enumerable -- countable sets

\item Co-recursively enumerable

\end{itemize}

% 155
% 22
% 23
% 170
% 98
% 141
% 54
% 163
% 115

\section{Cantor's diagonalization}

Cantor's diagonalization argument is a useful argument for proving
unenumerability of a set and hence it's uncomputability.

The original proof shows that the set of infinite bit-sequences is not
enumerable.

\begin{proof} Assume that sequence $S$ is an infinite sequence of infinite
sequences of bits. The claim is that regardless of the number of bit-sequences
in $S$ it is always possible to construct a bit-sequence not contained in $S$.

Such a sequence can be represented as a table:


Such a sequence is constructable by taking the complements of the elements along the diagonal of all 



\end{proof}


\section{The halting problem}

\section{Rice's statement}


\section{Primitive recursion}

All primitive recursive programs terminate.

\section{Introduction to size-change termination}

The size change termination .. why values should be well-founded

\section{The language to be defined}

The soft version.
