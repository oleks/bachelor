\newcommand{\D}{$\Delta$}
\chapter{The language \D{}}

The goal of this work is to describe a few automated termination analysis
techniques, and in particular, size-change termination. In order to allow for
the following chapters to retain a modest level of abstraction to the Turing
machine, such that the techniques are described for an environment that is
modestly applicable to solving moderate programming problems, a Turing complete
language \D{} is introduced.

\section{The intent of the language}

The intent of the language is two-fold, \begin{inparaenum}[(1)]\item aid the
descriptions of automated termination analysis techniques in latter
chapters, and \item be relatively expressive\end{inparaenum}.

Expressiveness of a language is a rather subjective and domain-driven concept.
First and foremost, expressiveness depends on the initial intended domain of
the language. Of course, Turing complete languages are known to be universally
applicable, however, some languages are just more fine tuned to solving some
problems, while others are better tuned to solving other problems.

\D{} is a language with very few primitive operations but is expressive enough
to write the Fibonacci and Ackermann functions in an elegant way. To do this,
\D{} borrows some syntax and semantics from purely functional languages such as
ML or Haskell. Hence, programs in \D{} make heavy use of pattern matching and
recursion to achieve branching and looping, some of the constructs required for
a language to be Turing complete.

Unlike ML and Haskell, \D{} is a language that completely disregards the
concepts of abstract data structures and types. Hence, many data driven
programs will be hard to write in \D{}. Of course, this is not to say that data
flow analysis is irrelevant to termination analysis as such, on the contrary,
it is key to size-change termination. It is because of this prime importance of
data flow to termination analysis, that data value representation is kept to
its almost lowest possible denominator. This keeps the analysis clean of rather
irrelevant abstract data structure fiddling. What's more, any methods developed
for \D{} can be extended and used in a language with types and abstract data
structures, as long as it is computationally equivalent to \D{}.

Also, unlike most purely functional languages, \D{} is a first-order,
call-by-value language. This is done in part to adhere to the general flow of
\cite{size-change}, and in part to keep the analysis simple at first.
Higher-order constructs impose difficulties when deducing changes in size, and
evaluation strategies other than call-by-value impose a similar sort of
difficulties.

\input{language/data}
\input{language/syntax}
\input{language/semantics}
\input{language/input}
\input{language/higher-order}
\input{language/samples}
