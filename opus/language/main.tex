\newcommand{\D}{$\Delta$}
\chapter{The language \D{}}

The goal of this work is to describe a few automated termination analysis
techniques, and in particular, size-change termination. In order to allow for
the following chapters to retain a modest level of abstraction to the Turing
machine, such that the techniques are described for an environment that is
modestly applicable to solving moderate programming problems, a Turing complete
language \D{} is introduced.

The intent of the language is hence two-fold, (1) aid the descriptions of the
automated termination analysis techniques in further chapters and (2) be
relatively modern in the subjective sense of expressiveness.

Expressiveness of a language depends on its initially intended domains. Of
course, Turing complete languages are known to be universally applicable,
however some languages are just more fine tuned to solving some problems, while
others are better tuned for solving other problems, hence the domain-specific
and subjective term of expressiveness.

\D{} is a language that disregards the aspect of abstract data structures.
Hence, many data driven programs \emph{will} be hard to write in \D{} due to,
for instance, the complete absence of types. This is of course, relative.
Various aspects of the data flow of a program can be important to various
automated termination analysis techniques, in particular size-change
termination. Hence, \D{} is not completely useless and does have data and even
simple ways of analyzing the sizes and shapes of its values and branching
depending on the outcome of such analyses.

\section{General properties}

One of the fundamental concepts required of the
language of application is that it's datatypes are well-founded. That is, any
subset $S$ of the range of values of some well-defined type has a value $s$
s.t. $\forall {s'\in S}\ s\leq s'$. This makes it ideal to chose some
oversimplistic data type structure rather than an army of basic types. Besides,
an apropriately defined basic data type should be able to represent arbitrarily
complex data values.

The language is initially first-order since the size-change termination
principle is first described for first-order programs later on in this work.
However, the language is designed so that it is easy to turn it into a
high-level language without much effort. This may prove necessary as we try to
expand size-change termination to higher-order programs.

The language is a call-by-value and purely functional to avoid any problems
that could arise from regarding lazy programs or where the notion of a global
state of the machine is relevant. Simply put, this is done to ensure elegance
of further proof with the help of the language.

The language \D{} is also Turing complete in the sense that it can model the
Turing machine.

\input{language/data}
\input{language/syntax}
\input{language/semantics}
\input{language/input}
\input{language/size}
\input{language/higher-order}
\input{language/samples}
