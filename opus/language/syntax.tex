\section{Syntax}\label{section:d-syntax}

We describe the syntax of \D{} in terms of an extended Backus-Naur
form\footnote{The extension lends some constructs from regular expressions to
achieve a more concise dialect. The extension is described in detail in
\referToAppendix{ebnf}.}. This is a core syntax definition, and other, more
practical, syntactical features may be defined later on as needed. The initial
non-terminal is $\nonterm{program}$.

\begin{align}
\nonterm{program}\ ::=&\ \nonterm{clause}^*\ \nonterm{expression}\\
\nonterm{expression}\ ::=&\ \nonterm{element}\ (\ \term{.}\ \nonterm{expression}
\ )\ ?\\
\nonterm{element}\ ::=&\ \term{0}\ |\ \term{(}\ \nonterm{element}\ \term{)}\ |
\ \nonterm{name}\ |\ \nonterm{application}\\
\nonterm{application}\ ::=&\ \nonterm{name}
\ \nonterm{expression}^+\\
\nonterm{clause}\ ::=&\ \nonterm{name}\ \nonterm{pattern}^+
\ \term{:=}\ \nonterm{expression}\\
\label{nonterm-pattern}
\nonterm{pattern}\ ::=&\ \nonterm{pattern-element}\ (\ \term{.}
\ \nonterm{pattern}\ )\ ?\\
\label{nonterm-pattern-element}
\nonterm{pattern-element}\ ::=&\ \term{0}\ |\ \term{\_}\ |\ \term{(}
\ \nonterm{pattern}\ \term{)}\ |\ \nonterm{name}\\
\nonterm{name}\ ::=&\ [\term{a}\mathmono{-}\term{z}]
\ \left (\ [\term{-}\ \term{a}\mathmono{-}\term{z}]^*
\ [\term{a}\mathmono{-}\term{z}]\ \right )?
\end{align}

\begin{definition} \referToTable{sos-definitions} defines shorthands for
various language constructs. We'll often refer to these in further discussions.
Additionally, we'll let the atoms $0$ and $\_$ represent
themselves.\end{definition} 

\makeTable[h!]
{sos-definitions}
{Shorthands for various language constructs for use in latter discussions. We
provide shorthands for an instance, a list, and the space of a construct. For
instance, $x$ is some particular expression, $X$ is some particular list of
expressions, and $\mathbb{X}$ is the set of all possible expressions.}
{|l|c|c|c|}
{\textbf{Description}&\textbf{Instance}&\textbf{Finite list}&\textbf{Space}}
{
Expression & $x$ & $X$ & $\mathbb{X}$\\
Element (of an expression) & $e$ & $E$ & $\mathbb{E}$\\
Function & $f$ & $F$ & $\mathbb{F}$\\
Clause & $c$ & $C$ & $\mathbb{C}$\\
Pattern & $p$ & $P$ & $\mathbb{P}$\\
Value & $b$ & $B$ & $\mathbb{B}$\\
Name & $v$ & $V$ & $\mathbb{V}$\\
Program & $r$ & $R$ & $\mathbb{R}$
}

%\begin{definition} The \nonterm{expression} at the end of \nonterm{program} can
%be considered as the main clause of a program, which we'll refer to as
%$c_{main}$.\end{definition}

\begin{definition} For any given $n\in\mathbb{N}$ and $P\subset\mathbb{P}$,
we say that $n\in P$ if $n$ occurs in some $p\in P$.\end{definition}

\begin{definition}\label{definition:clause-tuple} A clause $c\in\mathbb{C}$ is
a tuple $\left\langle n,P,x \right\rangle$, where $n\in\mathbb{N}$ is the name
of the clause, $P\subset\mathbb{P}$ is a non-empty list of patterns of the
clause, and $x\in\mathbb{X}$ is the expression of the clause. $P$ is ordered by
occurrence of the patterns in the program text.\end{definition}

\begin{definition} We say that a clause $c= \left\langle n,P,x \right\rangle$
``accepts'' an argument list $B$ iff $\forall\ \{i\mid 0\geq i < |P|\}\ b_i\in
B \wedge p_i\in P \wedge b_i\succ p_i$.\end{definition}

\begin{definition}\label{definition:function-tuple} A function $f\in\mathbb{F}$
is a tuple $\left\langle n_f,C \right\rangle$, where $n_f \in \mathbb{N}$ is
the name of the function, and $C\subset\mathbb{C}$ is the non-empty list of
clauses of the function. It must hold for $C$ that  $\forall\ c\in C\
\left(c=\left\langle n_c, P_c, x_c \right\rangle \wedge n_c=n_f\right)$ and
$\forall\ c_1,c_2\in C\ \left(c_1=\left\langle n_1, P_1, x_1 \right\rangle
\wedge c_2=\left\langle n_2, P_2, x_2 \right\rangle \wedge |P_1|=|P_2|\right)$.
$C$ is ordered by occurrence of the clauses in the program
text.\end{definition}

\begin{definition} A signature of some function $f=\left\langle n_f,C_f
\right\rangle$ is the tuple $\left\langle n_f,|P| \right\rangle$, s.t.
$\forall\ c\in C_f\ |P_c|=|P|$.  We'll adopt the Erlang notation when talking
about function signatures, i.e. if we have a function \mono{less} that takes in
two parameters, we'll refer to it as \mono{less/2}.\end{definition}

We assume for it to be fairly simple to construct the set $F$ of a given
program $r$ given the set of clauses $C$ derived during syntactic analysis of
the program text.

\begin{definition} A program $r$ is a tuple $\left\langle F,x \right\rangle$,
where $F\subset\mathbb{F}$ is the list of functions defined in program $r$ and
$x$ is the expression of program $r$.\end{definition}

\begin{definition} A function call is a tuple $\left\langle n, X
\right\rangle$, where $n\in\mathbb{N}$ is the name of the callee, and
$X\subset\mathbb{X}$ is a non-empty list of arguments for the function
call.\end{definition}

0-ary clauses are disallowed to avoid having to deal with constants in general.
The term $\term{\_}$ in $\nonterm{pattern-element}$ is the conventional
wildcard operator; it indicates a value that won't used in the clause
expression, but some value has to be there for an argument to match the
pattern. Furthermore, as will be clear from the semantics, multiple occurrences
of \term{\_} in a clause pattern list does not indicate that the same value has
to be in place for each \term{\_}. 

% TODO this should be clear from the semantics.

% Multiple wildcards in the parameter list indicate possibly different value
% arguments, while multiple occurances of the same variable name in the parameter
% list are disallowed.

\subsection{Patterns constitute shapes}

The nonterminal declarations for patterns, in particular \ref{nonterm-pattern}
and \ref{nonterm-pattern-element}, indicate that a pattern declaration is
indeed a shape specification. In particular, a value that matches a given
pattern specification matches the corresponding shape specification.

\begin{corollary} Patterns are shape specifications. In particular, a pattern
is either a node, a tree (underscore or variable name), or a node with two
patterns as children. This, together with \referToDefinition{shape} indicates
that a pattern is indeed a shape specification.\end{corollary}

\begin{definition} Given $p_1,p_2\in\mathbb{P}$, and their corresponding shapes
$s_1,s_2\in\mathbb{S}$, we say that $p_1\succ p_2$ if $s_1\succ s_2$. We hence
overload the binary relation $\succ$ with the set $\left\{(p_1,p_2)\mid
p_1\in\mathbb{P} \wedge p_2\in\mathbb{P} \wedge p_1\ \text{matches}\
p_2\right\}$.\end{definition}
