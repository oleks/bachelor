\section{Semantics}\label{section:d-sos}

% Revise the context of an expression within a function call, it should always be
% the context upon entering the function call! Or even better, the context when
% the function was defined!

% \textbf{Allow mutual recursion}

% \textbf{Perhaps pattern matching must be exhaustive in general.}

% \textbf{Every subsequent definition must be strictly less specific than the former.}

In the following section we describe the semantics of \D{} using a form of
structured operational semantics. The syntax used to define the reduction rules
is largely equivalent to the Aarhus report\cite{sos}, but differs
slightly\footnote{The syntax applied here is described in further detail in
\referToAppendix{sos}.}.

\subsection{The memory model}\label{section:d-semantics-memory}

\begin{definition}\label{definition:memory} Memory is considered in terms of a
binary relation $\sigma$ which for any given clause $c$ is the set $\{(n,b)\mid
n\in\mathbb{N} \wedge b\in\mathbb{B} \wedge n\in P_c\}$. For any given
$(n,b)\in\sigma_c$, we say that in the scope of $c$, the variable $n$, is bound
to $b$.\end{definition}

\begin{corollary}\label{corollary:init-empty-scope} Variables are bound when
arguments are matched to clause patterns, and if the argument matches a
pattern, hence before pattern matching the arguments for any given clause $c$,
$\sigma_c=\emptyset$.\end{corollary}

\referToDefinition{memory} and \referToCorollary{init-empty-scope} indicate
that \D{} is statically scoped.  Furthermore, \referToDefinition{memory} may
prove hampering if we were ever to extend \D{} with lambda calculus, but there
are initially no plans to do so.

\begin{definition} The \nonterm{expression} at the end of \nonterm{program} can
be considered as the main clause of a program, which we'll refer to as
$c_{main}$.\end{definition}

\begin{corollary} $\sigma_{c_{main}}=\emptyset$. \end{corollary}

% This renders $\sigma$ countably infinite since $\mathbb{V}$ is countably
% infinite.

\subsubsection{Functions and variables}

Due to \D{} being a first-order language, we should make sure to separate the
function and variable spaces. We'll represent these by $\phi$ and $\gamma$,
respectively.

Whenever we use $\sigma$, $\phi$ or $\gamma$ in set notation, we imply the sets
of the names of functions and variables, and not the stacks themselves
corresponding to those names.  Hence, $\sigma=\phi\cup\gamma$, and to keep \D{}
first-order we add the limitation that $\phi\cap\gamma=\emptyset$.

\subsubsection{Making \D{} higher order}

The only change that this would require is to let $\phi=\gamma=\sigma$.

\subsection{Function declarations}

Assuming that as a part of the semantic analysis all $\nonterm{declaration}$ with the same name are grouped into the set $\left\langle n F\right\rangle$

A declaration with a name $n$, a \emph{non-empty} pattern
list $P$ and an expression $e$ is stored in the function space $\phi$:

\begin{equation}\label{sem:declaration}
{\displaystyle
  \left\langle \phi(n)\mapsto \left\langle P, x, \phi\right\rangle\right\rangle
  \rightarrow
  \phi'
\over\displaystyle
  \left\langle n, P, x, \phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

\subsection{Expression evaluation}

An expression $x$ is either the element $e$, or a construction of an element
$e_1$ with another expression $x_1$. That is, the binary infix operator $\cdot$
is right-associative, and has the following operational semantics:

\everymath{\displaystyle}

\begin{equation}
{\displaystyle
  \left\langle \proc{Single}, x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
\vee
  \left\langle \proc{Chain}, x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
\over\displaystyle
  \left\langle x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
}
\end{equation}

\begin{equation}
{\displaystyle
  x\rightarrow e
\wedge
  \left\langle e,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
\over\displaystyle
  \left\langle \proc{Single}, x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
}
\end{equation}

\begin{equation}
{\displaystyle
  x\Rightarrow e_1\cdot x_1
\wedge
  \left\langle e_1,\sigma\right\rangle
  \rightarrow
  \left\langle v_1,\sigma\right\rangle
\wedge
  \left\langle x_1,\sigma\right\rangle
  \rightarrow
  \left\langle v_2,\sigma\right\rangle
\over\displaystyle
  \left\langle \proc{Chain}, x, \sigma\right\rangle
  \rightarrow
  \left\langle v, \sigma\right\rangle
}
\quad(\text{where }v_1\cdot v_2=v)
\end{equation}

\subsection{Element evaluation}

According to the syntax specification, an element of an expression can either
be the atom $0$, or an application. We'd like to distinguish between variables
and functions, and we do that  

\begin{equation}
{\displaystyle
\left(
    e\Rightarrow 0
  \wedge
    v\equiv 0
\right)
\vee
{\displaystyle
    e\Rightarrow n
\over\displaystyle
    \beta(n)\Rightarrow v
}
\vee
{\displaystyle
    e\Rightarrow \left\langle n, X\right\rangle
\over\displaystyle
    \left\langle n,X,\sigma\right\rangle
    \Rightarrow
    \left\langle v,\sigma\right\rangle
}
\over\displaystyle
\left\langle e,\sigma\right\rangle
\Rightarrow
\left\langle v,\sigma\right\rangle
}
\end{equation}

\subsection{Function application}

\begin{equation}
{\displaystyle
{\displaystyle
{\displaystyle
  \left\langle n, \phi\right\rangle
  \Rightarrow
  \left\langle P, x, \phi\right\rangle
\over\displaystyle
  \left\langle P, X, \sigma\right\rangle
  \Rightarrow
  \sigma'
}
\over\displaystyle
  \left\langle x, \sigma'\right\rangle
  \Rightarrow
  \left\langle v,\sigma'\right\rangle
}
\over\displaystyle
    \left\langle n,X,\sigma\right\rangle
    \Rightarrow
    \left\langle v,\sigma\right\rangle
}
\end{equation}

\subsection{Pattern matching}

\begin{equation}
{\displaystyle
{\displaystyle
  \left\langle P_{head}, X_{head}, \sigma\right\rangle
  \Rightarrow
  \sigma''
\over\displaystyle
  \left\langle P_{tail}, X_{tail}, \sigma''\right\rangle
  \Rightarrow
  \sigma'
}
\over\displaystyle
  \left\langle P, X, \sigma\right\rangle
  \Rightarrow
  \sigma'
}
\end{equation}

\begin{equation}
{
  \left\langle\proc{I}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
\vee
  \left\langle\proc{Z}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
\vee
  \left\langle\proc{N}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
\vee
  \left\langle\proc{P}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}\over{
  \left\langle p, x, \sigma\right\rangle
  \Rightarrow
  \left\langle p', x', \sigma'\right\rangle
}
\end{equation}

For the sake of an elegant notation, we'll override the function $\cdot$ for
patterns.

\begin{definition}

A pattern is an unlabeled of binary tree which is either empty or consists of
an unlabeled node with a $0$, $\_$, name, or a pattern as it's left and right
child. 

\end{definition}

\begin{definition}

Let the set of all possible patterns be denoted by $\mathbb{P}$.

\end{definition}

\begin{definition}

The function $\cdot
:\mathbb{P}\times\mathbb{P}\rightarrow\mathbb{P}$ constructs a pattern node with the
two arguments as it's left and right child, respectively. 

\end{definition}

\begin{equation}
{
    p\Rightarrow \_\cdot p'
  \wedge
    x\Rightarrow e\cdot x'
  \wedge
    \sigma\Rightarrow\sigma'
}\over{
  \left\langle\proc{Underscore}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}

\begin{equation}
{
    p\Rightarrow 0\cdot p'
  \wedge
    x\Rightarrow e\cdot x'
  \wedge
    \sigma\Rightarrow\sigma'
}\over{
  \left\langle\proc{Zero}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}


\begin{equation}
{\displaystyle
{\displaystyle
{\displaystyle
    p\Rightarrow n\cdot p'
  \wedge
    x\Rightarrow e\cdot x'
\over\displaystyle
    \left\langle e,\sigma\right\rangle
    \Rightarrow
    \left\langle v,\sigma\right\rangle
}\over\displaystyle
    \left\langle\sigma(n)\leftarrow v\right\rangle
    \Rightarrow
    \sigma'
}\over\displaystyle
  \left\langle\proc{Name}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}

\begin{equation}
{\displaystyle
{\displaystyle
    p\Rightarrow p''\cdot p'  
  \wedge
    x\Rightarrow x''\cdot x'
\over\displaystyle
  \left\langle p'', x'', \sigma\right\rangle
  \Rightarrow
  \sigma'
}
\over\displaystyle
  \left\langle\proc{Pattern}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}

\subsection{Deducing unary functions from multivariate functions}

When performing termination analysis of programs it may prove tedious to
consider a list of patterns rather than a single pattern, especially since a
multivariate function can always be encoded as a unary function with e.g. the
patterns \mono{a}, \mono{b}, \mono{c}, and d encoded as \mono{a.b.c.d}. The
same ``encoding'' would have to be applied to each call to the function as
well. Hence, we can limit ourselves to termination proofs of unary functions.
