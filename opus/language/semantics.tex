\section{Semantics}\label{section:d-sos}

Revise the context of an expression within a function call, it should always be
the context upon entering the function call! Or even better, the context when
the function was defined!


\textbf{Perhaps pattern matching must be exhaustive in general.}

\textbf{Every subsequent definition must be strictly less specific than the former.}




In the following section we describe the semantics of \D{} using structured
operational semantics. The syntax used to define the reduction rules is largely
equivalent to the Aarhus report\cite{sos}, but differs slightly\footnote{The
syntax applied here is described in further detail in \referToAppendix{sos}.}.
The most notable about the syntax used here is the following:

\begin{itemize}

\item Rules should be read in increasing order of equation number.

\item If some rule with a lower equation number makes use of an undefined
reduction rule, it is because the reduction rule is defined under some higher
equation number.

\item Rules can be defined in terms of themselves, i.e. they can be recursive,
even mutually recursive.

\end{itemize}

The syntax aside, \referToTable{sos-definitions} defines a few lower-letter
shorthands for various constructs. Additionally, we'll let the capital
equivalents of these letters represent a sets of the respective construct, as
well as let the atoms $0$ and $\_$ represent themselves in the reduction rules.
It is also worth noting that $\forall\ v\in V\ :\ v\in \mathbb{B}$.

\makeTable[h!]
{sos-definitions}
{Overview of some of the shorthands used in this text. The column \textbf{A}
refers to all possible instances of the given construct, i.e.  $\mathbb{B}$
reffers to all constructable values in \D{}. The column \textbf{P} refers to
all the instances of the given construct in a given program, i.e. $N$ reffers
to all the names in a given program. The column \textbf{I} reffers to specific
instances of the given constructs, i.e. $x$ reffers to a particular
expression.}
{|l|c|c|c|}
{\textbf{Description}&\textbf{I}&\textbf{P}&\textbf{A}}
{
Expression & $x$ & $X$ & $\mathbb{X}$\\
Element (of an expression) & $e$ & $E$ & $\mathbb{E}$\\
Pattern & $p$ & $P$ & $\mathbb{P}$\\
Value(binary tree) & $b$ & $B$ & $\mathbb{B}$\\
Name & $n$ & $N$ & $\mathbb{N}$
}

\subsection{The memory model}\label{section:d-semantics-memory}

Memory is considered in terms of a set of value stacks, $\sigma$. Every stack
has a unique identifier $n\in N$, that is, each variable in a given program
gets a value stack. As we enter a new scope, we bind a variable to a value,
that is, we push that value on top of the corresponding stack. We pop the value
off the corresponding stack as we leave the scope at the entry to which the
variable was bound.

An expression at a certain scope depth only has access to variables at the same
scope depth. This is to ensure static scope. We won't adhere to this problem
explicitly in the semantics, but instead ask you to simply keep it in mind.

\subsubsection{Functions and variables}

Due to \D{} being a first-order language, we should make sure to separate the
function and variable spaces. We'll represent these by $\phi$ and $\gamma$,
respectively.

Whenever we use $\sigma$, $\phi$ or $\gamma$ in set notation, we imply the sets
of the names of functions and variables, and not the stacks themselves
corresponding to those names.  Hence, $\sigma=\phi\cup\gamma$, and to keep \D{}
first-order we add the limitation that $\phi\cap\gamma=\emptyset$.

\subsubsection{Making \D{} higher order}

The only change that this would require is to let $\phi=\gamma=\sigma$.

\subsection{Declaration}

A declaration with a name $n$, a \emph{non-empty} pattern
list $[p]$ and an expression $e$ is stored in the function space $\phi$:

\begin{equation}\label{sem:declaration}
{\displaystyle
  \left\langle \phi(n)\leftarrow \left\langle P, x\right\rangle\right\rangle
  \Rightarrow
  \phi'
\over\displaystyle
  \left\langle n, P, x, \phi\right\rangle
  \Rightarrow
  \phi'
}
\end{equation}

\subsection{Expression evaluation}

An expression $x$ is either the element $e$, or a construction of an element
$e'$ with another expression $x'$. That is, the binary infix operator $\cdot$
is right-associative, and has the following operational semantics:

\everymath{\displaystyle}

\begin{equation}
{\displaystyle
  \left\langle \proc{Single}, x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
\vee
  \left\langle \proc{Chain}, x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
\over\displaystyle
  \left\langle x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
}
\end{equation}

\begin{equation}
{\displaystyle
  x\rightarrow e
\wedge
  \left\langle e,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
\over\displaystyle
  \left\langle \proc{Single}, x,\sigma\right\rangle
  \rightarrow
  \left\langle v,\sigma\right\rangle
}
\end{equation}

\begin{equation}
{\displaystyle
  x\Rightarrow e_1\cdot x_1
\wedge
  \left\langle e_1,\sigma\right\rangle
  \rightarrow
  \left\langle v_1,\sigma\right\rangle
\wedge
  \left\langle x_1,\sigma\right\rangle
  \rightarrow
  \left\langle v_2,\sigma\right\rangle
\over\displaystyle
  \left\langle \proc{Chain}, x, \sigma\right\rangle
  \rightarrow
  \left\langle v, \sigma\right\rangle
}
\quad(\text{where }v_1\cdot v_2=v)
\end{equation}

\subsection{Element evaluation}

According to the syntax specification, an element of an expression can either
be the atom $0$, or an application. We'd like to distinguish between variables
and functions, and we do that  

\begin{equation}
{\displaystyle
\left(
    e\Rightarrow 0
  \wedge
    v\equiv 0
\right)
\vee
{\displaystyle
    e\Rightarrow n
\over\displaystyle
    \beta(n)\Rightarrow v
}
\vee
{\displaystyle
    e\Rightarrow \left\langle n, X\right\rangle
\over\displaystyle
    \left\langle n,X,\sigma\right\rangle
    \Rightarrow
    \left\langle v,\sigma\right\rangle
}
\over\displaystyle
\left\langle e,\sigma\right\rangle
\Rightarrow
\left\langle v,\sigma\right\rangle
}
\end{equation}

\subsection{Function application}

\begin{equation}
{\displaystyle
{\displaystyle
{\displaystyle
  \left\langle n, \phi\right\rangle
  \Rightarrow
  \left\langle P, x, \phi\right\rangle
\over\displaystyle
  \left\langle P, X, \sigma\right\rangle
  \Rightarrow
  \sigma'
}
\over\displaystyle
  \left\langle x, \sigma'\right\rangle
  \Rightarrow
  \left\langle v,\sigma'\right\rangle
}
\over\displaystyle
    \left\langle n,X,\sigma\right\rangle
    \Rightarrow
    \left\langle v,\sigma\right\rangle
}
\end{equation}

\subsection{Pattern matching}

\begin{equation}
{\displaystyle
{\displaystyle
  \left\langle P_{head}, X_{head}, \sigma\right\rangle
  \Rightarrow
  \sigma''
\over\displaystyle
  \left\langle P_{tail}, X_{tail}, \sigma''\right\rangle
  \Rightarrow
  \sigma'
}
\over\displaystyle
  \left\langle P, X, \sigma\right\rangle
  \Rightarrow
  \sigma'
}
\end{equation}

\begin{equation}
{
  \left\langle\proc{I}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
\vee
  \left\langle\proc{Z}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
\vee
  \left\langle\proc{N}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
\vee
  \left\langle\proc{P}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}\over{
  \left\langle p, x, \sigma\right\rangle
  \Rightarrow
  \left\langle p', x', \sigma'\right\rangle
}
\end{equation}

For the sake of an elegant notation, we'll override the function $\cdot$ for
patterns.

\begin{definition}

A pattern is an unlabeled of binary tree which is either empty or consists of
an unlabeled node with a $0$, $\_$, name, or a pattern as it's left and right
child. 

\end{definition}

\begin{definition}

Let the set of all possible patterns be denoted by $\mathbb{P}$.

\end{definition}

\begin{definition}

The function $\cdot
:\mathbb{P}\times\mathbb{P}\rightarrow\mathbb{P}$ constructs a pattern node with the
two arguments as it's left and right child, respectively. 

\end{definition}

\begin{equation}
{
    p\Rightarrow \_\cdot p'
  \wedge
    x\Rightarrow e\cdot x'
  \wedge
    \sigma\Rightarrow\sigma'
}\over{
  \left\langle\proc{Underscore}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}

\begin{equation}
{
    p\Rightarrow 0\cdot p'
  \wedge
    x\Rightarrow e\cdot x'
  \wedge
    \sigma\Rightarrow\sigma'
}\over{
  \left\langle\proc{Zero}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}


\begin{equation}
{\displaystyle
{\displaystyle
{\displaystyle
    p\Rightarrow n\cdot p'
  \wedge
    x\Rightarrow e\cdot x'
\over\displaystyle
    \left\langle e,\sigma\right\rangle
    \Rightarrow
    \left\langle v,\sigma\right\rangle
}\over\displaystyle
    \left\langle\sigma(n)\leftarrow v\right\rangle
    \Rightarrow
    \sigma'
}\over\displaystyle
  \left\langle\proc{Name}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}

\begin{equation}
{\displaystyle
{\displaystyle
    p\Rightarrow p''\cdot p'  
  \wedge
    x\Rightarrow x''\cdot x'
\over\displaystyle
  \left\langle p'', x'', \sigma\right\rangle
  \Rightarrow
  \sigma'
}
\over\displaystyle
  \left\langle\proc{Pattern}, p,x,\sigma\right\rangle
  \Rightarrow
  \left\langle p',x',\sigma'\right\rangle
}
\end{equation}
