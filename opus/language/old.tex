\subsection{Size}


Hence, the tree \mono{0} has the value $0$, the tree \mono{0.0} has the value
$1$, and the tree \mono{0.0.0} has the value $2$ as does it's symmetrical
equivalent, \mono{(0.0).0}.

This allows us to define the, otherwise built-in, function \mono{less} in a
primitive recursive fashion as follows:

\begin{verbatim}
less 0 0 = 0
less _._ 0 = 0
less 0 _._ = 0.0
less A.B X.Y = 

less AR.AL BR.BL = or (and (less AR BR) (less AL BL))
\end{verbatim}

This definition indicates that we choose for the empty tree to represent the
value \emph{false}, and for the tree \mono{0.0} to represent the value
\emph{true}. We'll keep the definition even more generic, and let the
\emph{nonempty} tree represent the value \emph{true}, as shall become useful
when we define the higher-order function \mono{if}
(\referToSection{language-higher-order-built-ins}).

Since the values begin at $0$ and grow at the rate of $1$ ... we can define it
as syntactic sugar and use nonnegative integers where ...

In addition to defining the actual data type we need to specify how we're going
to reason about it. Specifically, the questions of equality and order of values
constructed in this manner have to be answered.

For all intents and purposes, we can let the \emph{absolute value} of such a
tree-structured value be equal to $n-1$, where $n$ is the number of leafs in
the tree. Hence, the tree \mono{0} denotes $0$, \mono{0.0} denotes 1,
\mono{0.0.0} denotes 2 and so on.

The choice of this data representation yields the following properties for the
construction and destruction operators:

\begin{lemma} Construction of value yields a value strictly greater than either
of it's constituents. Specifically, the absolute value of the new value is the
sum of the absolute values of the constituents.\end{lemma}

\begin{lemma} Destruction of a value yields a pair of values who's absolute
values are strictly less than the absolute value of the original
value.\end{lemma}


