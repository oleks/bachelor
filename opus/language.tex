\chapter{Language}

\section{The language \mono{D}}

In the following chapter the language \mono{D}\footnote{The choice of the
letter \mono{D} bares no special meaning.}\ is described in terms of an
extended Backus-Naur form\footnotemark. It is described in the simplest
possible terms, that is, extraneous syntactical sugar and basic terms are left
out of the core language definition.  Instead, these are defined as necessary
in the latter chapters.

\footnotetext{The extension lends some constructs from regular expressions to
achieve a more concise dialect. The extension is described in further detail in
Appendix \ref{appendix:ebnf}.}

The language \mono{D} is \emph{initially} a purely functional, first-order,
explicitly typed, call-by-value language.

Programs are defined as follows:

\begin{align}
\nonterm{program}\ &::=\ \nonterm{type}^*\ \nonterm{function}^*
\ \nonterm{expression}
\end{align}

Types are declared by means of infinite algebraic datatypes:

\begin{align}
\nonterm{type}\ ::=&\ \nonterm{type-name}
\ \term{:=}\ \nonterm{constructor}\ (\term{|}
\ \nonterm{constructor})^*\\
\nonterm{type-name}\ ::=&\ \nonterm{literal}\\
\nonterm{constructor}\ ::=&\ \nonterm{constructor-name}
\ (\term{of}\ \nonterm{type-name})?\\
\nonterm{constructor-name}\ ::=&\ \nonterm{literal}
\end{align}

Functions (and their arguments) are explicitly typed, consume at least one
argument and always yield a value as output:

\begin{align}
\nonterm{function}\ ::=&\ \nonterm{type-name}\ \nonterm{function-name}
\ \nonterm{argument}^+\ \term{:=}\ \nonterm{expression}\\
\nonterm{function-name}\ ::=&\ \nonterm{literal}\\
\nonterm{argument}\ ::=&\ \nonterm{type-name}\
\nonterm{argument-name}\\
\nonterm{argument-name}\ ::=&\ \nonterm{literal}
\end{align}

All of the $\mathmono{<}x\mathmono{-name>}$ declarations above make use of the
$\nonterm{literal}$ nonterminal. For simplicity we'll let this be a lowercased
dash-separated sequence of a-z characters:

\begin{align}
\nonterm{literal}\ &::=\ [\term{a}\mathmono{-}\term{z}]
\ \left (\ [\term{-}\ \term{a}\mathmono{-}\term{z}]^*
\ [\term{a}\mathmono{-}\term{z}]\ \right )?
\end{align}

It is important that the above $\mathmono{<}x\mathmono{-name>}$s are distinct
from one another. We'll avoid cluttering up the grammar and simply state the
following:

$$\nonterm{type-name}\cap\nonterm{constructor-name}\cap\nonterm{function-name}
\cap\nonterm{argument-name}\equiv\emptyset$$

Last but not least, the $\nonterm{expression}$ itself:

\begin{align}
\nonterm{expression}\ ::=&\ \nonterm{function-call}\ |\ \nonterm{constructor-call}\\
\nonterm{function-call}\ ::=&\ \nonterm{function-name}\ \term{(}
\ \nonterm{expression}^+\ \term{)}\\
\nonterm{constructor-call}\ ::=&\ \nonterm{constructor-name}
\ (\term{(}\ \nonterm{constructor-call}\ \term{)})?
\end{align}

Since this is an eager language, the number of expressions that a function call
takes must be the exact number of arguments defined for that function, and due
to it being typed, their types must correspond.

The $\nonterm{constructor-call}$ nonterminal is defined in terms of itself.
This would be absurd without a set of basic types. Such basic types will be
defined when they are appropriate.

If this definition should otherwise prove impractical in further affairs, such
as lack of some other basic types or basic functions, these will be introduced
as needed instead of them being included in the core grammar.
