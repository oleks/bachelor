\chapter{Language}

\section{The language \mono{D}}

In the following chapter the language \mono{D}\footnote{The choice of the
letter \mono{D} bares no special meaning.}\ is described in terms of an
extended Backus-Naur form\footnotemark. It is described in the simplest
possible terms, that is, extraneous syntactical sugar and basic terms are left
out of the core language definition.  Instead, these are defined as necessary
in the latter chapters.

\footnotetext{The extension lends some constructs from regular expressions to
achieve a more concise dialect. The extension is described in further detail in
Appendix \ref{appendix:ebnf}.}

\subsection{General properties}

The intent of the language is for it be used to explain concepts such as
size-change termination. One of the fundamental concepts required of the
language of application is that it's datatypes are well-founded. That is, any
subset $S$ of the range of values of some well-defined type has a value $s$
s.t. $\forall {s'\in S}\ s\leq s'$. This makes it ideal to chose some
oversimplistic data type structure rather than an army of basic types. Besides,
an apropriately defined basic data type should be able to represent arbitrarily
complex data values.

The language is initially first-order since the size-change termination
principle is first described for first-order programs later on in this work.
However, the language is designed so that it is easy to turn it into a
high-level language without much effort. This may prove necessary as we try to
expand size-change termination to higher-order programs.

The language is a call-by-value and purely functional to avoid any problems
that could arise from regarding lazy programs or where the notion of a global
state of the machine is relevant. Simply put, this is done to ensure elegance
of further proof with the help of the language.

\subsection{Data \& Functions}

%As Turing had mentioned in his novel analysis of
%computation\cite{turing-machine}, having values with inifinite precision yields
%values that differ to an infinite extent. This yields a requirement of
%inifinitely many discrete operations to tell such values apart, for which there
%cannot exist an effective procedure by it's mere definition. To remedy this
%issue, Turing made use of a representation of data where the values were mere
%finite sequences of atoms from a basic alphabet.

The language \mono{D} is untyped, and represents all data in terms of
\emph{unlabeled ordered binary trees}. Such a tree is recursively defined as
a finite set of nodes which is either empty or consists of a single node with
two trees as it's left and right child, respectively.

\mono{D} represents an empty tree with the atom \mono{0}. Node constrution is
done with the right-associative infix binary operator $\term{.}$, within
expressions. Node destruction is done with the exact same operator, except that
it is done while pattern matching an argument list to a parameter list of a
function declaration. Conventional braces can be used to override the
right-associativity of the $\term{.}$ operator in both cases.

Hence, the grammar for expressions and function declarations is defined as
follows:

\begin{align}
\nonterm{expression}\ ::=&\ \nonterm{value}\ (\ \term{.}\ \nonterm{expression}
\ )\ ?\\
\nonterm{value}\ ::=&\ \term{0}\ |\ \term{(}\ \nonterm{braces}\ \term{)}\ |
\ \nonterm{variable-name}\\
\nonterm{braces}\ ::=&\ \nonterm{expression}\ |
\ \nonterm{application}\\
\nonterm{application}\ ::=&\ \nonterm{function-name}
\ \nonterm{expression}^+\\
\nonterm{function}\ ::=&\ \nonterm{function-name}\ \nonterm{pattern}^+
\ \term{:=}\ \nonterm{expression}\\
\nonterm{pattern}\ ::=&\ \nonterm{pattern-value}\ (\ \term{.}
\ \nonterm{pattern}\ )\ ?\\
\nonterm{pattern-value}\ ::=&\ \term{0}\ |\ \term{\_}\ |\ \term{(}
\ \nonterm{pattern}\ \term{)}\ |\ \nonterm{variable-name}
\end{align}

The term $\term{\_}$ in $\nonterm{pattern-value}$ is the conventional wildcard
operator -- it indicates a value that is irrelevant to the function
declaration. Multiple wildcards in the parameter list indicate possibly
different value arguments, while multiple occurances of the same variable name
in the parameter list are disallowed.

It is worth noting that the sets $\nonterm{function-name}$ and
$\nonterm{variable-name}$ are disjoint, but are otherwise both defined by the
nonterminal $\nonterm{name}$:

\begin{align}
\nonterm{name}\ ::=&\ [\term{a}\mathmono{-}\term{z}]
\ \left (\ [\term{-}\ \term{a}\mathmono{-}\term{z}]^*
\ [\term{a}\mathmono{-}\term{z}]\ \right )?
\end{align}

\subsection{Size}

Althought the language is already complete, it would prove useful for further
analysis to define the notion of size, and hence the equality and order of
values.

\emph{We define the size of a value to be the number of nodes in the tree that
represents that value.}

Hence, the tree \mono{0} has the value $0$, the tree \mono{0.0} has the value
$1$, and the tree \mono{0.0.0} has the value $2$ as does it's symmetrical
equivalent, \mono{(0.0).0}.

This allows us to define the, otherwise built-in, function \mono{less} in a
primitive recursive fashion as follows:

\begin{verbatim}
less 0 0 = 0
less _._ 0 = 0
less 0 _._ = 0.0
less AR.AL BR.BL = or (and (less AR BR) (less AL BL))
\end{verbatim}

This definition indicates that we choose for the empty tree to represent the
value \emph{false}, and for the tree \mono{0.0} to represent the value
\emph{true}. We'll keep the definition even more generic, and let the
\emph{nonempty} tree represent the value \emph{true}, as shall become useful
when we define the higher-order function \mono{if}
(\referToSection{language-higher-order-built-ins}).

Since the values begin at $0$ and grow at the rate of $1$ ... we can define it
as syntactic sugar and use nonnegative integers where ...

In addition to defining the actual data type we need to specify how we're going
to reason about it. Specifically, the questions of equality and order of values
constructed in this manner have to be answered.

For all intents and purposes, we can let the \emph{absolute value} of such a
tree-structured value be equal to $n-1$, where $n$ is the number of leafs in
the tree. Hence, the tree \mono{0} denotes $0$, \mono{0.0} denotes 1,
\mono{0.0.0} denotes 2 and so on.

The choice of this data representation yields the following properties for the
construction and destruction operators:

\begin{lemma} Construction of value yields a value strictly greater than either
of it's constituents. Specifically, the absolute value of the new value is the
sum of the absolute values of the constituents.\end{lemma}

\begin{lemma} Destruction of a value yields a pair of values who's absolute
values are strictly less than the absolute value of the original
value.\end{lemma}

\subsection{Programs}

Programs are defined in a conventional functional context and without mutual
recursion, namely:

\begin{align}
\nonterm{program}\ ::=&\ \nonterm{function}^*\ \nonterm{expression}
\end{align}

The order of the function definitions does matter wrt. pattern matching in so
far as those defined before are attempted first, if the match fails, the next
function with the same signature\footnote{In this case comprising of the name
of the function and it's arity.} is attempted.

Note, that we let the number of function definitions be zero as an
$\nonterm{expression}$ is a valid program as well. More generally, the program
can be thought of as a constant function, where the actual
$\nonterm{expression}$ simply has access to some predefined functions defined
by the function definitions in the program.

\subsection{Built-in high-order
functions}\label{section:language-higher-order-built-ins}

Although \mono{D} is initially a first-order language, we will ignore that
limitation for a bit and define a few higher-order functions to provide some
syntactical sugar to the language. Beyond the discussion in this section, these
higher-order functions should be regarded as \mono{D} built-ins.

\subsubsection{Branching}

In the following definition, the variable names \mono{true} and \mono{false}
refer to expressions to be executed in either case.

\begin{verbatim}
if 0 _ false := false
if _._ _ true := true
\end{verbatim}

As you can see, we employ the C convention that any value other than $0$ is a
``truthy'' value, and the expression \mono{true} is returned.

Although the call-by-value nature of the language does not allow for
short-circuiting the if-statements defined in such a way, this shouldn't be any
impediment to further analysis.

\subsection{Sample programs}

As an illustration of the language syntax, the following program reverses a tree:

\begin{verbatim}
reverse 0 := 0
reverse left.right := (reverse right).(reverse left)
\end{verbatim}

The following program computes the Fibonacci number \mono{n}:

\begin{verbatim}
fibonacci 0 x y := 0
fibonacci 1 x y := y
fibonacci n x y := fibonacci (minus n 1) y (add x y)
\end{verbatim}

The definition of \mono{add}, \mono{minus} and indeed \mono{1}, depend heavily
on the definition of the notion of a size of a data value. If we let the size
of the data value simply be the number of dangling leafs then the definiitions:

Data is represented as unlabeled binary trees. The size of the data value is
simply the number of nodes in the tree, or equivalently the number of leaf
nodes minus 1. Leaf nodes suck as they are terribly inefficient. 

\section{Semantics}

In the following section, the operational semantics of the language \mono{D}
are defined in terms of structured operaitonal semantics\cite{sos}.

$$\langle E, s\rangle$$
