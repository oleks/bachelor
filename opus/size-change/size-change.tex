\section{Size-change termination principle}

Consider the program in \referToListing{cfg-loop} and its corresponding call
graph in \referToFigure{cfg-loop-pdf}. Without any further information about
the calls, the program seemingly loops indefinitely. However,
there are some things that we can deduce about the control transitions.

\begin{theorem}\label{theorem:size-change} If every call cycle in a given
program reduces a value of a well-founded data-type on each iteration of the
cycle, then the value must eventually bottom out and the program must
terminate.\end{theorem}

\begin{proof} Assume for the sake of contradiction that a program that reduces
a value of a well-founded data type in each call cycle does not terminate.
Then, either the value reduces indefinitely, which is a contradiction to the
well-foundedness of its data type, or some noncyclic call sequence causes an
infinite loop, also an absurdity due to the definition of \D{}. \end{proof}

That is the \emph{size-change termination principle}\cite{size-change}. All
values in \D{} are inherently well-founded so what remains to be shown is how
we can deduce from a call cycle whether it reduces a value on each iteration.

\begin{definition}\label{definition:size-relation} For a given call
graph $G = \left\langle C,E \right\rangle$, let a size relation be the set

$$
\Phi = \left\{ \left\langle c_s, c_t,x, v_s, v_t, \rho \right\rangle \left| 
\begin{array}{ll}
&\left\langle c_s, c_t,x \right\rangle \in E\\
\wedge&c_t = \left\langle \_, p_t, \_ \right\rangle \in C \\
\wedge&v_s,v_t\in\mathbb{V}\\
\wedge&v_s\Subset x \wedge v_t \Subset p_t \\
\wedge&\rho\in\{\bot, <, \leq\}
\end{array}
\right.\right\}
$$

\end{definition}

This definition implies that for each call cycle there may be multiple
variables\footnote{We'll define what we mean by a variable more formally in
\referToDefinition{variable}.} to ensure reduction for. However, as there is
only a finite number of variables in any given pattern and any given
expression, we can define these as separate cycles.

\begin{definition}\label{definition:variable-call-graph} Given a recursive call
graph $G^r = \left\langle C^r, E^r \right\rangle$, let $G^u= \left\langle C^u,
E^u \right\rangle$ be a ``unary recursive call graph'', where

$$E^u = \left\{ \left\langle c_s, c_t, x, v_s, v_t \right\rangle \left|
\begin{array}{ll}
&\left\langle c_s, c_t,x \right\rangle \in E^r\\
\wedge&c_t = \left\langle \_, p_t, \_ \right\rangle \in C^r \\
\wedge&v_s,v_t\in\mathbb{V}\\
\wedge&v_s\Subset x \wedge v_t \Subset p_t
\end{array}
\right.\right\},$$

and $C^u= \left\{ c \mid c \in C^r \wedge c\Subset E^u
\right\}$.\end{definition}

\begin{theorem} A unary recursive call graph $G^u$ has a finite number of
edges.\end{theorem}

\begin{proof} Follows from \referToDefinition{variable-call-graph} and the
semantics of \D{}.\end{proof}

\referToDefinition{variable-call-graph} forces us to redefine the concept of a
call cycle, as a sequence of clauses may have multiple cycles in $G^u$.

\begin{definition}\label{definition:variable-call-cycle} Given a recursive call
graph $G^r = \left\langle C^r, E^r \right\rangle$, let $Z^r$ denote the set of
call cycles in $G^r$, and $Z^u$ the set of call cycles in $G^u$, then

$$Z^u = \bigcup_{z^r\in Z^r} \left\{ \left\langle c_s, c_t, x, v_s, v_t \right\rangle \left|
\begin{array}{ll}
&\left\langle c_s, c_t,x \right\rangle \in z^r\\
\wedge&c_t = \left\langle \_, p_t, \_ \right\rangle \in C^r \\
\wedge&v_s,v_t\in\mathbb{V}\\
\wedge&v_s\Subset x \wedge v_t \Subset p_t
\end{array}
\right.\right\}.$$

\end{definition}

\referToDefinition{variable-call-graph} allows us now to more formally define
what we've thus far meant as a variable that changes value from call to call.

\begin{definition}\label{definition:variable} Given a unary recursive call
graph $G^u$, every call cycle $z$ in $G^u$, changes exactly one variable, call
it ``cycle variable'', or $v_z$.\end{definition}

Hence, while a variable may have different names in different clauses, we've
defined an overall variable for every call cycle, and want to ensure that this
variable is reduced in every iteration of the call cycle.

\begin{theorem}\label{theorem:multivariable-patterns} We can WLOG to
termination analysis limit our attention to programs that bind at most one
variable in every clause.\end{theorem}

\begin{proof} Let a recursive call graph $G^r$ have a set of call cycles $Z^r$,
and a corresponding unary recursive call graph $G^u$ with a set of call cycles
$Z^u$. By \referToDefinition{variable-call-cycle} and
\referToDefinition{size-relation}, every call cycle in $Z^r$ reduces a value
iff every call cycle in $Z^u$ reduces a value. We can hence limit our attention
to deducing if each call cycle in $Z^u$ reduces a value.\end{proof}

\begin{definition}\label{definition:nice-call-graph} Let $G^1$ denote a
recursive call graph of a program where each clause binds at most one
variable.\end{definition}

Given \referToTheorem{multivariable-patterns} we can return to the old
definition of a call graph as per \referToDefinition{recursive-call-graph} and
call cycle as per \referToDefinition{call-cycle}. This demands a
simplification of the size relation $\Phi$.

\begin{definition}\label{definition:unary-size-relation} For a given $G^1 =
\left\langle C,E \right\rangle$ of a program, let a size relation be the set

$$\Phi^1 = \left\{ \left\langle c_s, c_t,x, \rho \right\rangle \mid
\left\langle c_s, c_t,x \right\rangle \in E \wedge \rho\in\{\bot, <, \leq\}
\right\}$$

\end{definition}

\begin{definition}\label{definition:increasing-decreasing-call} Given a call
graph $G$ with a call cycle $z$, a call $\left\langle c_s,c_t,x\right\rangle\in
z$ is,

\begin{enumerate}

\item A ``decreasing call'' iff $\left\langle c_s,c_t,x,< \right\rangle \in
\Phi^1$.

\item A ``nonincreasing call'' iff $\left\langle c_s,c_t,x,\leq \right\rangle
\in \Phi^1$.

\item An ``undteremined call'' iff $\left\langle c_s,c_t,x,\bot \right\rangle
\in \Phi^1$.

\end{enumerate}

\end{definition}

\begin{lemma}\label{lemma:cycle-reduce} A call cycle $z= \left\langle c_1,c_2
\right\rangle, \left\langle c_2, c_3 \right\rangle,\ldots, \left\langle
c_{n-1}, c_n \right\rangle$ reduces a value on each iteration iff
$$\left(\forall\ \left\langle c_i,c_j \right\rangle \in z\ \left(\left\langle
c_i,c_j,\_, < \right\rangle \in \Phi^1\right) \vee \left(\left\langle
c_i,c_j,\_, \leq \right\rangle \in \Phi^1 \right)\right)\wedge \left( \exists\
\left\langle c_i,c_j \right\rangle \in z\ \left\langle c_i,c_j,\_, <
\right\rangle \in \Phi^1 \right)$$.\end{lemma}

\begin{proof} If a value is not reduced in a cycle, it either stays the same or
is increased. If it is increased, then at least one call must've increased the
value, which is an absurdity. If it stays the same then none of the
participating control transitions have neither increased nor decreased the
value, also an absurdity.\end{proof}

\subsection{Deducing $\Phi^1$}

Since \D{} is a call-by-value language, when a function call $\left\langle
v_t,x_s \right\rangle$ is encountered, the source evaluates $x_s$ and generates
some $b_s\in\mathbb{B}$ as the actual argument for the function call. The
expression $x_s$ is by definition a nested construction of either some concrete
value, some variable $v_s\in\mathbb{V}$ bound in the source, or a nested
function call. Without further regard of nested function calls, this implies
that a size relation can be deduced between the $v_s$ and $b_s$.

We decide to ignore the nested function calls because this would imply a more
complex static analysis of the program. Specifically, we're unable to say
anything about the result of the nested function call from the scope of the
source clause alone. Instead, we treat results from nested function calls
simply as variables with \emph{unknown} values. We also make sure to keep these
variables separate from the bound variables as there is no relationship to draw
between these ``variables'' and the variable that might be bound in the
target\footnote{While this information may be useful for dead-code elimination
and other forms of static analysis, this is of little importance to size-change
termination.}.

Due to nested functions calls being represented as variables with unknown
values, a precise size displacement between the bound variable $v_s$ and the
generated argument $b_s$ is not feasible. However, we can deduce a \emph{safe}
displacement estimate.

\begin{definition} A safe displacement estimate between the values
$b_1,b_2\in\mathbb{B}$ is a value $n\in\mathbb{N}$ s.t. $b_1+n\leq
b_2$.\end{definition}

\begin{definition} Given a function $\left\langle v_t,x_s\right\rangle$, we
construct the expression $x_s'$ where we replace all $\left\langle v,x
\right\rangle\Subset x_s'$ with an auxiliary variable. We group those auxiliary
variables in the set $V^s_{calls}$.\end{definition} 

For instance, consider an expression such as \mono{(g (f a).a)}, where \mono{a}
is some variable bound in the source. Assume that we're considering the the
call to the function \mono{g}, then we replace the expression \mono{(f a).a)}
with an expression like \mono{b.a} where $\textt{b}\in V^s_{calls}$. When this
argument evaluates to some value $b_s$, then we can safely say that
$b_s>\text{\mono{a}}$, $b_s>\text{\mono{b}}$, $b_s\geq\text{\mono{a.0}}$ and
$v\geq\text{\mono{0.b}}$.

Continuing on with the example above, i.e. having the size relations
$\{v>\textt{a}, v> \textt{b}, v\geq \textt{a.0}, v\geq \textt{0.b}\}$, assume
that the target clause has the corresponding pattern \mono{x.y}. The question
henceforth is how do we draw the relationship that $\textt{a}\equiv\textt{x}$
and $\textt{b}\equiv\textt{y}$, or perhaps simply that the control transition
neither decreases nor increases any values. We can perform a corresponding
analysis on the pattern declaration and deduce the set of conditions that will
hold after pattern matching succeeds, indeed, $\{v>\textt{x}, v> \textt{y},
v\geq \textt{x.0}, v\geq \textt{0.y}\}$. The participation of $x$ in the same
kind of relations as $a$, and the participation of $y$ in the same kind of
relations as $b$, does not alone indicate their respective equivalence, since
the actual property that $v\equiv\textt{a.b}$ is lost.

On the other hand, if we had to formally define the relation that had to be
built between the variables bound in the source and the values that the
function call arguments evaluated to, this would be a relation between values
and some kind of ``abstract patterns'', as e.g. $v\geq\textt{0.b}$.

To simplify the entire process, instead of deducing actual size relations
between the variables bound in the source and the values that the function
arguments evaluate to, we can simply turn the function argument into the
abstract pattern to begin with. The actual size relations are hence withkept
and can be deduced at a later stage in the process.

Indeed, the tuple $(x^s,N_{vars}^s,N_{calls}^s)$ constitutes such an abstract
pattern already, since the expression $x^s$, contains no function calls and
hence syntactically matches a pattern in \D{}\footnote{See
\referToSection{d-syntax} if you're uncertain.}. We henceforth refer to such an
expression as $p^s$\footnote{Where $s$ stands for \emph{source}.}. Given a
clause with the pattern $p^t$\footnote{Where $t$ stands for \emph{target}.}, we
can easily deduce the set $N_{vars}^t$, which is the set of variable names used
in $p$. Our task is then to deduce a size relation between the variables in the
sets $N_{vars}^s$ and $N_{vars}^t$ given the tuples
$(p^s,N_{vars}^s,N_{calls}^s)$ and $(p^t,N_{vars}^t)$.

\subsection{Pattern matching}

Let the function $\phi\ :\ \mathbb{N} \times \mathbb{N} \rightarrow
\{<,\leq,\bot\}$ denote the function $\lambda N^t, N^s .
\Phi\left(C^t,C^s,N^t,N^s\right)$. In the following section we will discuss the
rules involved in deducing the function $\phi$, that is, the function $\Phi$
for some given source and target of a success transition.

For this purpose we will regard the tuples $(P^s,N_{vars}^s)$ and
$(P^t,N_{vars}^t)$, of a given success transition, where $P^s$ is the list of
abstract patterns derived from the function arguments in the source, and $P^t$
is the list of corresponding actual patterns in the target. Furthermore, let
$N_{vars}^s$ and $N_{vars}^t$ be unary functions of the type
$\mathbb{P}\rightarrow\mathbb{N}^*$, accepting a pattern and yielding the
variable names that are contained both in the input pattern and the sets
$N_{vars}^s$ and $N_{vars}^t$, respectively.

In the following analysis we will look at but one instance of the lists $P^s$
and $P^t$, namely the abstract pattern $p^s$ from the source and its
corresponding actual pattern in the declaration, $p^t$. In total, however, this
process has to be repeated for each such pair given the sets $P^s$ and $P^t$,
iteratively extending the definition of the relation $\phi$ to all variables
bound in the sets $N_{vars}^s$ and $N_{vars}^t$.

We initially define $\phi$ to yield the value $\bot$ for all arguments. We will
continuously modify this definition as we process $p^s$ and $p^t$. We denote
this within the semantics in a manner similar to the state $\sigma$ in the
semantics\footnote{See \referToSection{d-sos}.}. However, $\phi$ is now a
binary ``memory'', requiring both a target name and a source name (in that
order). For simplicity, we will borrow some suger coding from the matlab
notation which allows us to provide a collection in place of a single element
and let the runtime apply the given function to each element in the collection.
For instance, we might write that $\phi\left(N_{vars}^t(p^t), n^s\right)\mapsto
<$, meaning that all the target variables used in $p^t$ are strictly less than
the source variable $n^s$.

We now define a summoning rule, dividing the rules up into sub-rules:

\begin{equation}
{
    \left\langle\proc{A},p^t,p^s,\phi\right\rangle
    \rightarrow
    \phi'
  \vee
    \left\langle\proc{B},p^t,p^s,\phi\right\rangle
    \rightarrow
    \phi'
  \vee
    \left\langle\proc{C},p^t,p^s,\phi\right\rangle
    \rightarrow
    \phi'
  \vee
    \left\langle\proc{D},p^t,p^s,\phi\right\rangle
    \rightarrow
    \phi'
  \vee
    \left\langle\proc{E},p^t,p^s,\phi\right\rangle
    \rightarrow
    \phi'
}\over{
  \left\langle p^t,p^s,\phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

One of the simpler cases is when the abstract pattern $p^s$ is simply \mono{0},
or some name $n^s$, and $n^s\in N_{calls}^s$. Since no variables bound in the
source participate in $p^s$, then no relations need to be drawn to any of the
target variables that might appear in the corresponding $p^t$. Hence, $\phi$
need not be modified.

\begin{equation}\label{eq:sct-pattern-source-fail}
{
\left(
    p^s\rightarrow 0
  \vee
\left(
    p^s\rightarrow n^s
  \wedge
    n^s\notin N_{vars}^s
\right)
\right)
  \wedge
    \phi\rightarrow\phi'
}\over{
  \left\langle\proc{A},p^t,p^s,\phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

This has a symmetrical case. Indeed when $p^t$ is neither a destruction, nor
any name $n^t$, that is, it is \mono{\_} or \mono{0}. This pattern contains no
variables, and hence  no relations need to be drawn from any of the variables
that might appear in the corresponding $p^s$. Hence, $\phi$ need not be
modified in such a case either.

\begin{equation}
{
\left(
    p^t\rightarrow 0
\vee
    p^t\rightarrow \_
\right)
  \wedge
    \phi\rightarrow\phi'
}\over{
  \left\langle\proc{B},p^t,p^s,\phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

If $p^t$ is the name pattern $n^t$, the matters get a bit more complicated:

\begin{enumerate}

\item If $p^s$ is some node, then all the variables that occur in $p^s$, i.e.
$N_{vars}^s(p^s)$, will all be strictly less than $n^t$ by the semantics of
\D{}. However, we are not concerned with this relation, as we would like to
know when a value is decreased from source to target, and not, as in this case,
increased.

\item If $p^s$ is also some name pattern $n^s$, and  $n^s\in N^s_{vars}$, then
the values of these corresponding variables will be \emph{equivalent}. However,
we're not concerned with exact equivalence, and simply mark this relationship
with the weaker, but still sound relation, $\leq$:

\begin{equation}
{
    p^t\rightarrow n^t
  \wedge
    p^s\rightarrow n^s
  \wedge
    n^s\in N_{vars}^s
  \wedge
    \left\langle\phi\left(n^t, n^s\right)\mapsto \leq\right\rangle\rightarrow\phi'
}\over{
  \left\langle\proc{C},p^t,p^s,\phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

\end{enumerate}

If $p^t$ is a destruction and $p^s$ is the variable name $n^s$, then we can safely say that
all the variables that occur in $p^t$, i.e. $N_{vars}^t(p^t)$, are all strictly less
than the variable in $n^s$:

\begin{equation}
{
    p^t\rightarrow p^t_1\cdot p^t_2
  \wedge
    p^s\rightarrow n^s
  \wedge
    n^s\in N_{vars}^s
  \wedge
    \left\langle\phi\left(N_{vars}^t(p^t), n^s\right)\mapsto <\right\rangle\rightarrow\phi'
}\over{
  \left\langle\proc{D},p^t,p^s,\phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

If both $p^t$ and $p^s$ are a destructions, then the following recursive rule applies:

\begin{equation}
{
    p^t\rightarrow p^t_1\cdot p^t_2
  \wedge
    p^s\rightarrow p^s_1\cdot p^s_2
  \wedge
    \left\langle p^t_1, p^s_1, \phi\right\rangle
    \rightarrow
    \phi''
  \wedge
    \left\langle p^t_2, p^s_2, \phi''\right\rangle
    \rightarrow
    \phi'
}\over{
  \left\langle\proc{E},p^t,p^s,\phi\right\rangle
  \rightarrow
  \phi'
}
\end{equation}

\section{Graph annotation}

Hence, we can deduce from \referToListing{cfg-loop}, that when $f_1$ makes a
call to $f_0$ it does so with a value strictly less then its own argument,
i.e. the transition $f_1\rightarrow f_0$ strictly decreases a value. Visually
we will mark this with a $\downarrow$. The Lemmas \refer{lemma:d-pattern-leq}
and \refer{lemma:d-pattern-less} can be used to deduce the same sort of
relationship for the transitions $r_1\xrightarrow{0,1} r_0$ for
\referToListing{cfg-reverse}. These observations are summarised in
\referToFigure{sct-first}.

\input{figures/sct-first}

\subsection{Calls to multivariate functions}

The call graph notation used thus far has only been used for describing calls
to unary functions. As an example of a multivariate function, we may consider
the function \mono{normalized-less/2}, introduced in
\referToSection{d-size-less}. We use this function to define the program in
\referToListing{sct-normalized-less}. The corresponding call graph is shown in
\referToFigure{sct-normalized-less}.

\begin{lstlisting}[
  label={listing:sct-normalized-less},
  caption={A sample program with a multivariate function.}]
n0: normalized-less 0 b := b
n1: normalized-less _ 0 := 0
n2: normalized-less _.a _.b := normalized-less a b
normalized-less input input
\end{lstlisting}

\input{figures/sct-normalized-less}

The notation is straightforward, the juxtaposition of the $\downarrow$
indicates the size change of the respective arguments, read left to right as in
the function clause definition.

\subsection{Nonincreasing transitions}

There are cases where for a given transition in a call cycle, we can't tell
whether the sizes are strictly decreased or remain the same, but we can
definitely say that there is \emph{no increase} in the sizes of variables. As
an example, consider the program in \referToListing{sct-non-reducing}.

\begin{lstlisting}[
  label=listing:sct-non-reducing,
  caption={The binary function \mono{g} has a call cycle with nonincreasing
    sizes in variables.}]
g0: g 0 0 = 0
g1: g _.a b._ = g 0.a b.0
g input input
\end{lstlisting}


For the recursive clause $g_1$, it is unclear whether the sizes of the
variables are decreased in the transition $g_1\rightarrow g_0$, or not.
Specifically, if the arguments to \mono{g} are of the form \mono{0.\_} and
\mono{\_.0}, respectively, the size is \emph{not} decreased by the call. We'll
denote such transitions by the symbol $\Downarrow$. We can now draw the call
graph for the program in \referToListing{sct-non-reducing} as in
\referToFigure{sct-non-reducing}.

\input{figures/sct-non-reducing}

\subsection{Increasing transitions}


%Values are not always decreasing.

%Consider the following program:

\begin{lstlisting}[
  label=listing:sct-infinite-join,
  caption={The function \mono{infinite-join/2} infinitely joins..}]
f0: f a b = f a.b b.a
f input input
\end{lstlisting}

%The function clause expression constructs a new value by joining the two
%incoming arguments into a new node. While we're unable to say by how much the
%values are increased exactly, we know that both values are increased by at
%least 1 due to the creation of a node for each argument.


%\newpage

%A derrivable property from the program text is that the value sent as the
%argument in the transition $F_1\rightarrow F_0$ is \emph{always} strictly less
%than the value sent as the argument in the preceeding transition,
%$F_0\rightarrow F_1$. Additionally, we can universally state that \emph{false
%transitions from case nodes by definition can't change any values}. Hence, the
%infinite control flow sequence $F_0\rightarrow F_1\rightarrow F_0$ strictly
%decreases a well founded value in every iteration of the control flow cycle.
%This means that eventually the value bottoms out at $0$ which would validate
%the $F_0$ pattern and lead the program to terminate. In general, we can state
%the following:

%\begin{lemma}

%An infinite control flow sequnece infinitely decreases a well founded value if
%all the transitions in the corresponding control flow graph cycle either
%strictly decrease a value or keep all values unchanged, and at least one
%transition strictcly decreases a value.

%\end{lemma}

%\referToFigure{cfg-loop-down} showcases an edge-labelled control flow graph for
%\referToListing{d-loop}. Transitions for which we can \emph{safely} say that a
%value is decreased we mark with the symbol $\downarrow$, transitions for which
%we can \emph{safely} say that no value is increased we mark with the symbol
%$\top$. The graph is rather verbose and in future graphs we'll omit $\top$
%labels for nodes that universally can't increase a value, i.e. $S\rightarrow
%F_0$, $F_0\rightarrow E$ and $F_0\rightarrow F_1$.

%We can further prove the soundness of the size-change termination principle.

%\begin{proof} Assume for the sake of contradiction that there exists an
%infinite control flow sequence that infinitely decreases a well-founded data
%value. Assume furthermore that the program does not terminate. Then, some
%variable has to decrease indefinately, which contradicts with the definition of
%well-founded values. \end{proof}

%Unfortunately, this particular program can be trivially unfolded into a loop
%program, so the point of using size-change termination analysis may seem
%superflous. Indeed, the only change wrt. the control flow diagram is the
%notaiton used in the diagram. For such programs, the termination property is
%easily derrivable\cite{complexity-of-loop-programs}. 

